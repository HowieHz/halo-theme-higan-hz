name: Reusable Audit

on:
  workflow_call:
    inputs:
      run_lighthouse_ci:
        required: false
        type: boolean
        default: false
      lighthouse_ci_version:
        required: false
        type: string
        default: "0.15.x"
      upload_screenshots_artifact:
        required: false
        type: boolean
        default: false
        description: "When true, capture screenshots and upload them as a workflow artifact."
      halo_version:
        required: false
        type: string
        default: "2.22.0-alpha.2"
      theme_ref:
        required: false
        type: string
        default: "refs/heads/main"
      ref_name:
        required: true
        type: string
        description: "Reference name for artifacts (current/base)"
      output_dir:
        required: false
        type: string
        default: "./reports/"
        description: "Directory to output the generated reports"
      output_filename:
        required: false
        type: string
        default: "page-size-report"
        description: "Base filename for the generated report"
      json_only:
        required: false
        type: boolean
        default: false
        description: "Generate JSON report only"
      upload_lighthouse_artifact:
        required: false
        type: boolean
        default: false
        description: "When true, upload raw Lighthouse .lighthouseci data as an artifact."
      playwright_browsers:
        required: false
        type: string
        default: "chromium,firefox,webkit"
        description: "Comma-separated list of Playwright browsers to install/run (eg: 'chromium,firefox,webkit'). Empty disables Playwright browser install."

jobs:
  precheck:
    name: Validate Secrets & Inputs
    runs-on: ubuntu-latest
    outputs:
      screenshots_needed: ${{ steps.check.outputs.screenshots_needed }}
    steps:
      - id: check
        continue-on-error: true
        run: |
          if [ "${{ inputs.upload_screenshots_artifact }}" = "true" ]; then
            echo "screenshots_needed=true" >> $GITHUB_OUTPUT
          else
            echo "screenshots_needed=false" >> $GITHUB_OUTPUT
          fi

  audit:
    needs: precheck
    if: ${{ inputs.run_lighthouse_ci == true || needs.precheck.outputs.screenshots_needed == 'true' }}
    name: Page Audit (${{ inputs.ref_name }})
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout ${{ inputs.ref_name }}
        uses: actions/checkout@v6
        with:
          ref: ${{ inputs.theme_ref }}

      - name: Copy latest .github scripts
        run: |
          # Fetch latest .github scripts (from the branch that triggered the workflow)
          # For PRs: use head_ref (source branch); otherwise use ref_name
          BRANCH_NAME="${{ github.head_ref || github.ref_name }}"
          echo "Workflow branch: $BRANCH_NAME"

          git fetch origin "$BRANCH_NAME"
          git checkout "origin/$BRANCH_NAME" -- .github/scripts/

          echo "‚úì Copied latest .github/scripts/ from $BRANCH_NAME"

          # ========== Phase 1: Prepare environment (serial, quick) ==========
      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 24
          cache: pnpm

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 21

      # ========== Phase 2: Parallel execution (main time-consuming part) ==========
      - name: Parallel Build Theme and Setup Halo
        shell: bash
        run: |
          set -e
          
          # Record environment information
          JAVA_VERSION=$(java -version 2>&1 | head -n 1 | awk -F '"' '{print $2}')
          echo "JAVA_VERSION=${JAVA_VERSION}" >> $GITHUB_ENV
          HALO_VERSION="${{ inputs.halo_version }}"
          echo "HALO_VERSION=${HALO_VERSION}" >> $GITHUB_ENV
          
          mkdir -p ~/logs
          
          # ============ Task 1: Theme build ============
          (
            set -e
            # lightweight timing: record task and key step timestamps (milliseconds)
            task_start=$(date +%s%3N)
            echo "TASK_START:${task_start}" > ~/logs/theme.timing

            echo "üì¶ [Theme] Start build"

            step_start=$(date +%s%3N); echo "STEP_START:pnpm-install:${step_start}" >> ~/logs/theme.timing
            pnpm install
            step_end=$(date +%s%3N); echo "STEP_END:pnpm-install:${step_end}" >> ~/logs/theme.timing

            step_start=$(date +%s%3N); echo "STEP_START:pnpm-build:${step_start}" >> ~/logs/theme.timing
            pnpm build
            step_end=$(date +%s%3N); echo "STEP_END:pnpm-build:${step_end}" >> ~/logs/theme.timing

            mkdir -p ~/builds/tmp ~/builds/target

            step_start=$(date +%s%3N); echo "STEP_START:pack-files:${step_start}" >> ~/logs/theme.timing
            cp -r . ~/builds/tmp
            mkdir -p ~/builds/tmp-included
            cd ~/builds/tmp
            cat "${{ github.workspace }}/.github/include-list.txt" | xargs -I {} cp -r --parents {} ~/builds/tmp-included/
            cd ~/builds/tmp-included
            zip -9 -r howiehz-higan-cn.zip .
            mv howiehz-higan-cn.zip ~/builds/target/
            step_end=$(date +%s%3N); echo "STEP_END:pack-files:${step_end}" >> ~/logs/theme.timing

            task_end=$(date +%s%3N); echo "TASK_END:${task_end}" >> ~/logs/theme.timing
            echo "‚úÖ [Theme] Complete"
          ) > ~/logs/theme.log 2>&1 &
          THEME_PID=$!
          
          # ============ Task 2: Halo setup ============
          (
            set -e
            # lightweight timing for Halo setup (milliseconds)
            task_start=$(date +%s%3N)
            echo "TASK_START:${task_start}" > ~/logs/halo.timing

            echo "üîß [Halo] Start setup"

            step_start=$(date +%s%3N); echo "STEP_START:download-jar:${step_start}" >> ~/logs/halo.timing
            # Download Halo
            # Try GitHub Releases first; fallback to the official mirror on failure
            if ! wget -q "https://github.com/halo-dev/halo/releases/download/v${HALO_VERSION}/halo-${HALO_VERSION}.jar" -O ~/halo.jar; then
              wget -q "https://dl.halo.run/release/halo-${HALO_VERSION}.jar" -O ~/halo.jar
            fi
            step_end=$(date +%s%3N); echo "STEP_END:download-jar:${step_end}" >> ~/logs/halo.timing

            # Create configuration
            step_start=$(date +%s%3N); echo "STEP_START:create-config:${step_start}" >> ~/logs/halo.timing
            mkdir -p ~/.halo2
            cat > ~/.halo2/application.yaml << 'EOF'
          server:
            port: 8090
          spring:
            r2dbc:
              url: r2dbc:h2:file:///${user.home}/.halo2/db/halo?MODE=MySQL&DB_CLOSE_ON_EXIT=FALSE
              username: admin
              password: admin
            sql:
              init:
                mode: always
                platform: h2
            thymeleaf:
              cache: true
          halo:
            security:
              basic-auth:
                disabled: false
            work-dir: ${user.home}/.halo2
            external-url: http://localhost:8090
          EOF
            step_end=$(date +%s%3N); echo "STEP_END:create-config:${step_end}" >> ~/logs/halo.timing

            # Start Halo
            step_start=$(date +%s%3N); echo "STEP_START:start-jar:${step_start}" >> ~/logs/halo.timing
            nohup java -jar ~/halo.jar \
              --spring.config.additional-location=optional:file:${HOME}/.halo2/ \
              -Dfile.encoding=UTF-8 > ~/logs/halo-startup.log 2>&1 &
            echo $! > ~/halo.pid
            step_end=$(date +%s%3N); echo "STEP_END:start-jar:${step_end}" >> ~/logs/halo.timing

            # Wait for readiness
            step_start=$(date +%s%3N); echo "STEP_START:wait-readiness:${step_start}" >> ~/logs/halo.timing
            for i in {1..60}; do
              if curl -sf http://localhost:8090/actuator/health/readiness >/dev/null 2>&1; then
                echo "‚úÖ [Halo] Ready (attempt ${i})"
                break
              fi
              [ $i -eq 60 ] && { echo "‚ùå [Halo] Timeout"; cat ~/logs/halo-startup.log; exit 1; }
              sleep 1
            done
            step_end=$(date +%s%3N); echo "STEP_END:wait-readiness:${step_end}" >> ~/logs/halo.timing

            # Initialize system
            step_start=$(date +%s%3N); echo "STEP_START:init-system:${step_start}" >> ~/logs/halo.timing
            echo "Initializing Halo system..."
            response=$(curl -c /tmp/cookies.txt -s http://localhost:8090/system/setup)
            csrf_token=$(echo "$response" | grep '_csrf' | sed -n 's/.*value="\([^\"]*\)".*/\1/p')

            curl -b /tmp/cookies.txt -X POST \
              http://localhost:8090/system/setup \
              -H "Content-Type: application/x-www-form-urlencoded" \
              -d "_csrf=${csrf_token}" \
              -d "language=zh-CN" \
              -d "externalUrl=http://localhost:8090" \
              -d "siteTitle=0" \
              -d "username=admin" \
              -d "email=admin@example.com" \
              -d "password=admin" \
              -d "confirmPassword=admin" \
              -L -s > /dev/null
            step_end=$(date +%s%3N); echo "STEP_END:init-system:${step_end}" >> ~/logs/halo.timing

            task_end=$(date +%s%3N); echo "TASK_END:${task_end}" >> ~/logs/halo.timing
            echo "‚úÖ [Halo] Complete"
          ) > ~/logs/halo.log 2>&1 &
          HALO_PID=$!
          
          # ============ Wait and check results ============
          echo "‚è≥ Waiting for parallel tasks..."
          
          wait $THEME_PID
          THEME_CODE=$?
          wait $HALO_PID
          HALO_CODE=$?
          
          if [ $THEME_CODE -ne 0 ]; then
            echo "‚ùå Theme build failed"
            cat ~/logs/theme.log
            exit 1
          fi
          
          if [ $HALO_CODE -ne 0 ]; then
            echo "‚ùå Halo setup failed"
            cat ~/logs/halo.log
            exit 1
          fi
          
          echo "üéâ All parallel tasks succeeded!"
          
          # Output timing stats for the first parallel group
          echo ""
          echo "‚è±Ô∏è  Timing for first parallel group (Build & Setup):"
          for tf in ~/logs/theme.timing ~/logs/halo.timing; do
            [ -f "$tf" ] || continue
            name=$(basename "$tf" .timing)
            start=$(awk -F: '/^TASK_START:/ {print $2; exit}' "$tf" || true)
            end=$(awk -F: '/^TASK_END:/ {print $2; exit}' "$tf" || true)
            if [ -n "$start" ] && [ -n "$end" ]; then
              total_ms=$((end - start))
              total_s=$(awk -v m="$total_ms" 'BEGIN{printf "%.2f", m/1000}')
              echo "- $name: total ${total_s}s"
            else
              echo "- $name: total unknown"
            fi

            awk -F: '/^STEP_START:/ {print $2":"$3}' "$tf" | while IFS= read -r s; do
              step_name=$(echo "$s" | cut -d: -f1)
              step_start=$(echo "$s" | cut -d: -f2)
              step_end=$(awk -F: -v st="$step_name" '$1=="STEP_END" && $2==st {print $3; exit}' "$tf" || true)
              if [ -n "$step_start" ] && [ -n "$step_end" ]; then
                step_ms=$((step_end - step_start))
                step_s=$(awk -v m="$step_ms" 'BEGIN{printf "%.2f", m/1000}')
                echo "  - $step_name: ${step_s}s"
              else
                echo "  - $step_name: unknown"
              fi
            done
          done

      # ========== Phase 3: Subsequent steps (serial) ==========
      - name: Install and activate theme
        run: |
          THEME_ZIP_PATH="${HOME}/builds/target/howiehz-higan-cn.zip"
          
          if [ ! -f "$THEME_ZIP_PATH" ]; then
            echo "‚ùå Theme file not found: $THEME_ZIP_PATH"
            exit 1
          fi
          
          echo "Installing theme..."
          response=$(curl -v -X POST \
            http://localhost:8090/apis/api.console.halo.run/v1alpha1/themes/install \
            -u admin:admin \
            -F "file=@${THEME_ZIP_PATH}" \
            -w "\nHTTP_CODE:%{http_code}" \
            2>&1)
          
          http_code=$(echo "$response" | grep "HTTP_CODE:" | cut -d: -f2)
          
          if [ -z "$http_code" ] || ([ "$http_code" != "200" ] && [ "$http_code" != "201" ]); then
            echo "‚ùå Theme installation failed (HTTP $http_code)"
            echo "$response"
            exit 1
          fi
          
          echo "‚úì Theme installed"
          
          curl -X PUT \
            http://localhost:8090/apis/api.console.halo.run/v1alpha1/themes/howiehz-higan/activation \
            -u admin:admin \
            -s > /dev/null
          
          echo "‚úì Theme activated"
          
          curl -X PUT \
            http://localhost:8090/apis/api.console.halo.run/v1alpha1/themes/howiehz-higan/invalidate-cache \
            -u admin:admin \
            -s > /dev/null
          
          echo "‚úì Cache cleared"

      - name: Disable Halo plugins
        shell: bash
        run: |
          set -e
          
          echo "Disable plugins: PluginCommentWidget, PluginSearchWidget"
          
          PIDS=()
          
          for plugin in PluginCommentWidget PluginSearchWidget; do
            (
              echo "üîß Disabling ${plugin}"
              if curl -sX PUT \
                "http://localhost:8090/apis/api.console.halo.run/v1alpha1/plugins/${plugin}/plugin-state" \
                -u admin:admin \
                -H "Content-Type: application/json" \
                -d '{"async":false,"enabled":false}'; then
                echo "‚úÖ ${plugin} disabled successfully"
              else
                echo "‚ö†Ô∏è  ${plugin} disable failed (ignored)"
              fi
            ) &
            PIDS+=($!)
          done
          
          echo "‚è≥ Waiting for plugin disable tasks..."
          
          for pid in "${PIDS[@]}"; do
            wait $pid || echo "‚ö†Ô∏è background job $pid exited with status $?"
          done
          
          echo "üéâ Plugins disabled"

      - name: Update site basic config favicon
        shell: bash
        run: |
          set -e
          echo "Fetching current system basic config"
          cfg=$(curl -s -u admin:admin http://localhost:8090/apis/console.api.halo.run/v1alpha1/systemconfigs/basic)
          if [ -z "$cfg" ]; then
            echo "‚ö†Ô∏è Empty response when fetching basic config"
            exit 1
          fi

          # Ensure jq is available
          if ! command -v jq >/dev/null 2>&1; then
            echo "‚ö†Ô∏è jq is required but not installed. Installing jq..."
            sudo apt-get update -y && sudo apt-get install -y jq || { echo "Failed to install jq"; exit 1; }
          fi

          echo "Current config:"
          echo "$cfg" | jq .

          # Set favicon field
          updated=$(echo "$cfg" | jq '.favicon = "/themes/howiehz-higan/assets/images/logo.avif"')

          echo "Updating basic config with new favicon"
          http_code=$(curl -s -o /tmp/put.out -w "%{http_code}" -u admin:admin -X PUT \
            http://localhost:8090/apis/console.api.halo.run/v1alpha1/systemconfigs/basic \
            -H "Content-Type: application/json" \
            -d "$updated")

          if [ "$http_code" -ge 200 ] && [ "$http_code" -lt 300 ]; then
            echo "‚úì basic config updated (HTTP $http_code)"
          else
            echo "‚ùå Failed to update basic config (HTTP $http_code)"
            echo "Response body:"; sed -n '1,200p' /tmp/put.out || true
            exit 1
          fi

      - name: Update site SEO description
        shell: bash
        run: |
          set -e
          echo "Fetching current system seo config"
          cfg=$(curl -s -u admin:admin http://localhost:8090/apis/console.api.halo.run/v1alpha1/systemconfigs/seo)
          if [ -z "$cfg" ]; then
            echo "‚ö†Ô∏è Empty response when fetching seo config"
            exit 1
          fi

          # Ensure jq is available
          if ! command -v jq >/dev/null 2>&1; then
            echo "‚ö†Ô∏è jq is required but not installed. Installing jq..."
            sudo apt-get update -y && sudo apt-get install -y jq || { echo "Failed to install jq"; exit 1; }
          fi

          echo "Current seo config:"
          echo "$cfg" | jq .

          # Set description field to "1"
          updated=$(echo "$cfg" | jq '.description = "1"')

          echo "Updating seo config with new description"
          http_code=$(curl -s -o /tmp/put.seo.out -w "%{http_code}" -u admin:admin -X PUT \
            http://localhost:8090/apis/console.api.halo.run/v1alpha1/systemconfigs/seo \
            -H "Content-Type: application/json" \
            -d "$updated")

          if [ "$http_code" -ge 200 ] && [ "$http_code" -lt 300 ]; then
            echo "‚úì seo config updated (HTTP $http_code)"
          else
            echo "‚ùå Failed to update seo config (HTTP $http_code)"
            echo "Response body:"; sed -n '1,200p' /tmp/put.seo.out || true
            exit 1
          fi
      
      - name: Pre-warm homepage
        run: |
          for i in 1 2 3; do
            curl -fsSL "http://localhost:8090/" > /dev/null || true &
          done
          wait

      - name: Run Lighthouse CI and Playwright (parallel)
        if: ${{ inputs.run_lighthouse_ci == true && needs.precheck.outputs.screenshots_needed == 'true' }}
        shell: bash
        run: |
          set -e
          mkdir -p ~/logs

          # Expose PLAYWRIGHT_BROWSERS from workflow input to the script
          PLAYWRIGHT_BROWSERS="${{ inputs.playwright_browsers }}"
          export PLAYWRIGHT_BROWSERS

          # ============ Task A: Lighthouse CI ============
          (
            set -e
            # timing for LHCI task (milliseconds)
            task_start=$(date +%s%3N)
            echo "TASK_START:${task_start}" > ~/logs/lhci.timing

            echo "üì¶ [LHCI] Install LHCI"
            step_start=$(date +%s%3N); echo "STEP_START:check-lhci:${step_start}" >> ~/logs/lhci.timing
            if ! command -v lhci >/dev/null 2>&1; then
              pnpm add -g @lhci/cli@${{ inputs.lighthouse_ci_version }} || echo "‚ö†Ô∏è  LHCI install failed, continuing"
            else
              echo "‚úì lhci already installed"
            fi
            step_end=$(date +%s%3N); echo "STEP_END:check-lhci:${step_end}" >> ~/logs/lhci.timing
            echo "LIGHTHOUSE_CI_VERSION=$(lhci --version 2>/dev/null || echo 'unknown')" >> $GITHUB_ENV

            echo "üöÄ [LHCI] Run Lighthouse CI"
            step_start=$(date +%s%3N); echo "STEP_START:lhci-run:${step_start}" >> ~/logs/lhci.timing
            mkdir -p ./reports
            lhci autorun \
              --collect.url=http://localhost:8090/ \
              --collect.url=http://localhost:8090/archives \
              --collect.url=http://localhost:8090/archives/hello-halo \
              --collect.url=http://localhost:8090/tags \
              --collect.url=http://localhost:8090/tags/halo \
              --collect.url=http://localhost:8090/categories \
              --collect.url=http://localhost:8090/categories/default \
              --collect.url=http://localhost:8090/authors/admin \
              --collect.url=http://localhost:8090/about \
              --collect.numberOfRuns=1 \
              --collect.settings.preset=desktop \
              --collect.settings.throttling.rttMs=0 \
              --collect.settings.throttling.throughputKbps=0 \
              --collect.settings.throttling.cpuSlowdownMultiplier=1 \
              --collect.settings.throttling.requestLatencyMs=0 \
              --collect.settings.throttling.downloadThroughputKbps=0 \
              --collect.settings.throttling.uploadThroughputKbps=0 \
              --upload.target=filesystem \
              --upload.outputDir=.lighthouseci || {
                echo "‚ùå [LHCI] Lighthouse CI failed"
                ls -la ./.lighthouseci/ || echo ".lighthouseci directory not found"
                exit 1
              }
            step_end=$(date +%s%3N); echo "STEP_END:lhci-run:${step_end}" >> ~/logs/lhci.timing
            task_end=$(date +%s%3N); echo "TASK_END:${task_end}" >> ~/logs/lhci.timing
            echo "‚úÖ [LHCI] Complete"
          ) > ~/logs/lhci.log 2>&1 &
          LHCI_PID=$!

          # ============ Task B: Playwright ============
          (
            set -e
            # timing for Playwright task (milliseconds)
            task_start=$(date +%s%3N)
            echo "TASK_START:${task_start}" > ~/logs/playwright.timing

            echo "üì¶ [Playwright] Install Playwright"
            step_start=$(date +%s%3N); echo "STEP_START:check-playwright:${step_start}" >> ~/logs/playwright.timing
            if ! pnpm exec -- playwright --version >/dev/null 2>&1; then
              pnpm add -w -D playwright @argos-ci/playwright || echo "‚ö†Ô∏è  Playwright install failed, continuing"
            else
              echo "‚úì playwright already available via pnpm exec"
            fi
            step_end=$(date +%s%3N); echo "STEP_END:check-playwright:${step_end}" >> ~/logs/playwright.timing

            step_start=$(date +%s%3N); echo "STEP_START:install-browsers:${step_start}" >> ~/logs/playwright.timing
            # Install Playwright browsers according to PLAYWRIGHT_BROWSERS (comma-separated)
            if [ -n "$PLAYWRIGHT_BROWSERS" ]; then
              # convert commas to spaces for CLI
              BROWSERS=$(echo "$PLAYWRIGHT_BROWSERS" | tr ',' ' ')
              echo "üì¶ Installing Playwright browsers: $BROWSERS"
              pnpm exec playwright install --with-deps $BROWSERS || echo "‚ö†Ô∏è Playwright browser install failed (continuing)"
            else
              echo "‚ö†Ô∏è PLAYWRIGHT_BROWSERS is empty ‚Äî defaulting to chromium"
              pnpm exec playwright install --with-deps chromium || echo "‚ö†Ô∏è Playwright browser install failed (continuing)"
            fi
            step_end=$(date +%s%3N); echo "STEP_END:install-browsers:${step_end}" >> ~/logs/playwright.timing


            echo "üì∏ [Playwright] Take screenshots"
            step_start=$(date +%s%3N); echo "STEP_START:screenshots:${step_start}" >> ~/logs/playwright.timing
            mkdir -p screenshots
            node .github/scripts/playwright-screenshots.js
            step_end=$(date +%s%3N); echo "STEP_END:screenshots:${step_end}" >> ~/logs/playwright.timing

            task_end=$(date +%s%3N); echo "TASK_END:${task_end}" >> ~/logs/playwright.timing
            echo "‚úÖ [Playwright] Complete"
          ) > ~/logs/playwright.log 2>&1 &
          PLAY_PID=$!

          echo "‚è≥ Waiting parallel tasks..."
          wait $LHCI_PID
          LHCI_CODE=$?
          wait $PLAY_PID
          PLAY_CODE=$?

          if [ $LHCI_CODE -ne 0 ]; then
            echo "‚ùå LHCI task failed. Log output:"
            if [ -f ~/logs/lhci.log ]; then
              sed -n '1,200p' ~/logs/lhci.log
            else
              echo "‚ÑπÔ∏è  Log file not found: ~/logs/lhci.log"
            fi
            exit $LHCI_CODE
          fi

          if [ $PLAY_CODE -ne 0 ]; then
            echo "‚ùå Playwright task failed. Log output:"
            if [ -f ~/logs/playwright.log ]; then
              sed -n '1,200p' ~/logs/playwright.log
            else
              echo "‚ÑπÔ∏è  Log file not found: ~/logs/playwright.log"
            fi
            exit $PLAY_CODE
          fi

          echo "üéâ Both LHCI and Playwright tasks succeeded"
          
          # Only output timing for the second parallel group
          echo ""
          echo "‚è±Ô∏è  Timing for second parallel group (LHCI & Playwright):"
          for tf in ~/logs/lhci.timing ~/logs/playwright.timing; do
            [ -f "$tf" ] || continue
            name=$(basename "$tf" .timing)
            start=$(awk -F: '/^TASK_START:/ {print $2; exit}' "$tf" || true)
            end=$(awk -F: '/^TASK_END:/ {print $2; exit}' "$tf" || true)
            if [ -n "$start" ] && [ -n "$end" ]; then
              total_ms=$((end - start))
              total_s=$(awk -v m="$total_ms" 'BEGIN{printf "%.2f", m/1000}')
              echo "- $name: total ${total_s}s"
            else
              echo "- $name: total unknown"
            fi

            awk -F: '/^STEP_START:/ {print $2":"$3}' "$tf" | while IFS= read -r s; do
              step_name=$(echo "$s" | cut -d: -f1)
              step_start=$(echo "$s" | cut -d: -f2)
              step_end=$(awk -F: -v st="$step_name" '$1=="STEP_END" && $2==st {print $3; exit}' "$tf" || true)
              if [ -n "$step_start" ] && [ -n "$step_end" ]; then
                step_ms=$((step_end - step_start))
                step_s=$(awk -v m="$step_ms" 'BEGIN{printf "%.2f", m/1000}')
                echo "  - $step_name: ${step_s}s"
              else
                echo "  - $step_name: unknown"
              fi
            done
          done

      - name: Run Lighthouse CI only
        if: ${{ inputs.run_lighthouse_ci && needs.precheck.outputs.screenshots_needed != 'true' }}
        shell: bash
        run: |
          set -e
          mkdir -p ~/logs

          # Only run Lighthouse CI
          task_start=$(date +%s%3N)
          echo "TASK_START:${task_start}" > ~/logs/lhci.timing

          echo "üì¶ [LHCI] Install LHCI"
          step_start=$(date +%s%3N); echo "STEP_START:check-lhci:${step_start}" >> ~/logs/lhci.timing
            if ! command -v lhci >/dev/null 2>&1; then
            pnpm add -g @lhci/cli@${{ inputs.lighthouse_ci_version }} || echo "‚ö†Ô∏è  LHCI install failed, continuing"
          else
            echo "‚úì lhci already installed"
          fi
          step_end=$(date +%s%3N); echo "STEP_END:check-lhci:${step_end}" >> ~/logs/lhci.timing
          echo "LIGHTHOUSE_CI_VERSION=$(lhci --version 2>/dev/null || echo 'unknown')" >> $GITHUB_ENV

          echo "üöÄ [LHCI] Run Lighthouse CI"
          step_start=$(date +%s%3N); echo "STEP_START:lhci-run:${step_start}" >> ~/logs/lhci.timing
          mkdir -p ./reports
          lhci autorun \
            --collect.url=http://localhost:8090/ \
            --collect.url=http://localhost:8090/archives \
            --collect.url=http://localhost:8090/archives/hello-halo \
            --collect.url=http://localhost:8090/tags \
            --collect.url=http://localhost:8090/tags/halo \
            --collect.url=http://localhost:8090/categories \
            --collect.url=http://localhost:8090/categories/default \
            --collect.url=http://localhost:8090/authors/admin \
            --collect.url=http://localhost:8090/about \
            --collect.numberOfRuns=1 \
            --collect.settings.preset=desktop \
            --collect.settings.throttling.rttMs=0 \
            --collect.settings.throttling.throughputKbps=0 \
            --collect.settings.throttling.cpuSlowdownMultiplier=1 \
            --collect.settings.throttling.requestLatencyMs=0 \
            --collect.settings.throttling.downloadThroughputKbps=0 \
            --collect.settings.throttling.uploadThroughputKbps=0 \
            --upload.target=filesystem \
            --upload.outputDir=.lighthouseci || {
              echo "‚ùå [LHCI] Lighthouse CI failed"
              ls -la ./.lighthouseci/ || echo ".lighthouseci directory not found"
              exit 1
            }
          step_end=$(date +%s%3N); echo "STEP_END:lhci-run:${step_end}" >> ~/logs/lhci.timing
          task_end=$(date +%s%3N); echo "TASK_END:${task_end}" >> ~/logs/lhci.timing
          echo "‚úÖ [LHCI] Complete"

      - name: Run Playwright
        if: ${{ inputs.run_lighthouse_ci == false && needs.precheck.outputs.screenshots_needed == 'true' }}
        shell: bash
        run: |
          set -e
          mkdir -p ~/logs

          # timing for Playwright+Argos task (milliseconds)
          task_start=$(date +%s%3N)
          echo "TASK_START:${task_start}" > ~/logs/playwright.timing

          echo "üì¶ [Playwright] Install Playwright and Argos"
          step_start=$(date +%s%3N); echo "STEP_START:check-playwright:${step_start}" >> ~/logs/playwright.timing
          if ! pnpm exec -- playwright --version >/dev/null 2>&1; then
            pnpm add -w -D playwright @argos-ci/playwright || echo "‚ö†Ô∏è  Playwright install failed, continuing"
          else
            echo "‚úì playwright already available via pnpm exec"
          fi
          step_end=$(date +%s%3N); echo "STEP_END:check-playwright:${step_end}" >> ~/logs/playwright.timing

          step_start=$(date +%s%3N); echo "STEP_START:install-browsers:${step_start}" >> ~/logs/playwright.timing
          # Use workflow input `playwright_browsers` when provided (comma-separated).
          PLAYWRIGHT_BROWSERS="${{ inputs.playwright_browsers }}"
          export PLAYWRIGHT_BROWSERS

          if [ -n "$PLAYWRIGHT_BROWSERS" ]; then
            BROWSERS=$(echo "$PLAYWRIGHT_BROWSERS" | tr ',' ' ')
            echo "üì¶ Installing Playwright browsers: $BROWSERS"
            pnpm exec playwright install --with-deps $BROWSERS || echo "‚ö†Ô∏è Playwright browser install failed (continuing)"
          else
            echo "‚ö†Ô∏è PLAYWRIGHT_BROWSERS is empty ‚Äî defaulting to chromium"
            pnpm exec playwright install --with-deps chromium || echo "‚ö†Ô∏è Playwright browser install failed (continuing)"
          fi

          step_end=$(date +%s%3N); echo "STEP_END:install-browsers:${step_end}" >> ~/logs/playwright.timing

          echo "üì∏ [Playwright] Take screenshots"
          step_start=$(date +%s%3N); echo "STEP_START:screenshots:${step_start}" >> ~/logs/playwright.timing
          mkdir -p screenshots
          node .github/scripts/playwright-screenshots.js
          step_end=$(date +%s%3N); echo "STEP_END:screenshots:${step_end}" >> ~/logs/playwright.timing

          task_end=$(date +%s%3N); echo "TASK_END:${task_end}" >> ~/logs/playwright.timing
          echo "‚úÖ [Playwright] Complete"
      
      - name: Upload screenshots (${{ inputs.ref_name }})
        if: ${{ (failure() && inputs.ref_name != 'base' && inputs.upload_screenshots_artifact) || inputs.upload_screenshots_artifact }}
        uses: actions/upload-artifact@v4
        with:
          name: screenshots-${{ inputs.ref_name }}
          path: ./screenshots/
          include-hidden-files: true
          if-no-files-found: warn
        
      - name: Upload Lighthouse raw data (${{ inputs.ref_name }})
        if: ${{ (failure() && inputs.run_lighthouse_ci) || inputs.upload_lighthouse_artifact == true }}
        uses: actions/upload-artifact@v4
        with:
          name: lighthouse-raw-data-${{ inputs.ref_name }}
          path: ./.lighthouseci/
          include-hidden-files: true
          if-no-files-found: warn

      - name: Generate reports (${{ inputs.ref_name }})
        id: generate_reports
        if: success() && inputs.run_lighthouse_ci
        env:
          OUTPUT_DIR: ${{ inputs.output_dir }}
          OUTPUT_FILENAME: ${{ inputs.output_filename }}
          JSON_ONLY: ${{ inputs.json_only }}
          LIGHTHOUSE_RESULTS_DIR: ./.lighthouseci/
          HALO_VERSION: ${{ env.HALO_VERSION }}
          JAVA_VERSION: ${{ env.JAVA_VERSION }}
          THEME_VERSION: ${{ inputs.theme_ref }}
          GITHUB_SHA: ${{ github.sha }}
          LIGHTHOUSE_CI_VERSION: ${{ env.LIGHTHOUSE_CI_VERSION }}
          REF_NAME: ${{ inputs.ref_name }}
        run: |
          if [ ! -d "./.lighthouseci" ]; then
            echo "‚ö†Ô∏è  Warning: .lighthouseci directory not found"
            exit 1
          fi
          
          json_count=$(find ./.lighthouseci -name "lhr-*.json" | wc -l)
          if [ "$json_count" -eq 0 ]; then
            echo "‚ö†Ô∏è  Warning: No Lighthouse result files found"
            exit 1
          fi
          
          echo "Found $json_count Lighthouse result files"
          node .github/scripts/generate-page-size-report.js

      - name: Upload reports (${{ inputs.ref_name }})
        if: ${{ steps.generate_reports.outcome == 'success' && inputs.run_lighthouse_ci }}
        uses: actions/upload-artifact@v4
        with:
          name: page-size-reports-${{ inputs.ref_name }}
          path: ${{ inputs.output_dir }}

      - name: Stop Halo
        if: always()
        run: |
          if [ -f ~/halo.pid ]; then
            kill "$(cat ~/halo.pid)" 2>/dev/null || echo "‚ö†Ô∏è kill failed (maybe already stopped)"
          fi

      - name: Upload logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: logs-${{ inputs.ref_name }}
          path: ~/logs/
